from pytest import raises
from unittest.mock import patch, Mock

from sqlalchemy.exc import IntegrityError

from mash.mash_exceptions import MashDBException
from mash.services.api.utils.users import (
    add_user,
    verify_login,
    get_user_by_email,
    get_user_by_id,
    delete_user,
    reset_user_password,
    change_user_password,
    is_password_dirty
)

from werkzeug.local import LocalProxy


@patch.object(LocalProxy, '_get_current_object')
@patch('mash.services.api.utils.users.db')
def test_add_user(mock_db, mock_get_current_object):
    app = Mock()
    mock_get_current_object.return_value = app
    app.config = {
        'EMAIL_WHITELIST': ['user1@fake.com'],
        'DOMAIN_WHITELIST': []
    }
    user = add_user('user1@fake.com', 'password123')

    assert user.email == 'user1@fake.com'

    # autogenerated password
    user = add_user('user1@fake.com')

    assert user.email == 'user1@fake.com'

    # User duplicate
    mock_db.session.commit.side_effect = IntegrityError(
        'Duplicate', None, None
    )
    user = add_user('user1@fake.com', 'password123')

    assert user is None
    mock_db.session.rollback.assert_called_once_with()

    # Password too short
    with raises(MashDBException):
        add_user('user1@fake.com', 'pass')

    # Not in email whitelist
    app.config = {
        'EMAIL_WHITELIST': ['user2@fake.com'],
        'DOMAIN_WHITELIST': []
    }
    with raises(MashDBException):
        add_user('user1@fake.com', 'password123')

    # Not in domain whitelist
    app.config = {
        'EMAIL_WHITELIST': [],
        'DOMAIN_WHITELIST': ['suse.com']
    }
    with raises(MashDBException):
        add_user('user1@fake.com', 'password123')


@patch('mash.services.api.utils.users.get_user_by_email')
def test_verify_login(mock_get_user):
    user = Mock()
    user.check_password.side_effect = [True, False]
    mock_get_user.return_value = user

    assert verify_login('user1@fake.com', 'password123') == user
    assert verify_login('user1@fake.com', 'password321') is None


@patch('mash.services.api.utils.users.User')
def test_get_user_by_id(mock_user):
    user = Mock()
    queryset = Mock()
    queryset.first.return_value = user
    mock_user.query.filter_by.return_value = queryset

    assert get_user_by_id(1) == user


@patch('mash.services.api.utils.users.add_user')
@patch('mash.services.api.utils.users.User')
def test_get_user_by_email(mock_user, mock_add_user):
    user = Mock()
    queryset = Mock()
    queryset.first.return_value = user
    mock_user.query.filter_by.return_value = queryset

    assert get_user_by_email('user1@fake.com') == user

    queryset.first.return_value = None
    get_user_by_email('user1@fake.com', create=True)

    mock_add_user.assert_called_once_with('user1@fake.com')


@patch.object(LocalProxy, '_get_current_object')
@patch('mash.services.api.utils.users.handle_request')
@patch('mash.services.api.utils.users.db')
@patch('mash.services.api.utils.users.get_user_by_id')
def test_delete_user(
    mock_get_user, mock_db, mock_handle_request, mock_get_current_object
):
    user = Mock()
    user.id = 1
    mock_get_user.return_value = user

    app = Mock()
    mock_get_current_object.return_value = app
    app.config = {'CREDENTIALS_URL': 'http://localhost:5000/'}

    assert delete_user(1) == 1
    mock_db.session.delete.assert_called_once_with(user)

    mock_handle_request.assert_called_once_with(
        'http://localhost:5000/',
        'credentials/1',
        'delete'
    )

    mock_get_user.return_value = None
    assert delete_user(1) == 0


@patch.object(LocalProxy, '_get_current_object')
@patch('mash.services.api.utils.users.db')
@patch('mash.services.api.utils.users.get_user_by_email')
def test_reset_user_password(
    mock_get_user, mock_db, mock_get_current_object
):
    user = Mock()
    user.id = 1
    mock_get_user.return_value = user

    app = Mock()
    mock_get_current_object.return_value = app

    assert reset_user_password('email@test.com') == 1
    mock_db.session.commit.assert_called_once_with()
    app.notification_class.send_notification.call_count == 1
    assert user.password_dirty is True

    mock_get_user.return_value = None
    assert reset_user_password('email@test.com') == 0


@patch.object(LocalProxy, '_get_current_object')
@patch('mash.services.api.utils.users.db')
@patch('mash.services.api.utils.users.get_user_by_email')
def test_change_user_password(
    mock_get_user, mock_db, mock_get_current_object
):
    user = Mock()
    user.id = 1
    user.check_password.return_value = True
    mock_get_user.return_value = user

    app = Mock()
    mock_get_current_object.return_value = app

    result = change_user_password(
        'email@test.com',
        'oldpass',
        'newpass'
    )
    assert result == 1
    mock_db.session.commit.assert_called_once_with()
    app.notification_class.send_notification.call_count == 1
    assert user.password_dirty is False

    mock_get_user.return_value = None
    result = change_user_password(
        'email@test.com',
        'oldpass',
        'newpass'
    )
    assert result == 0


@patch('mash.services.api.utils.users.get_user_by_email')
def test_is_password_dirty(mock_get_user):
    user = Mock()
    user.id = 1
    user.password_dirty = False
    mock_get_user.return_value = user

    result = is_password_dirty('email@test.com')
    assert result is False
